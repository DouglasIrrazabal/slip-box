# LeetCode Pattern Roadmap: Optimizing Your Interview Prep
This repository contains structured information on various algorithms and data structures, categorized by their potential return on investment (ROI) in terms of problem-solving efficiency and usefulness.

## High-ROI Patterns with Easy Learning
### Linked Lists
These are fundamental data structures where nodes are connected in a linear sequence. Mastering them is crucial for understanding memory allocation and manipulation, making them a must-learn for any coding interview.
### Tree BFS (Breadth-First Search)
This algorithm explores a tree structure level by level, visiting all nodes at a given depth before moving to the next. It's a versatile technique for finding shortest paths or specific nodes in trees.
### Graph BFS (Breadth-First Search)
Similar to Tree BFS, but applied to graphs, where nodes can have multiple connections. BFS can be used for tasks like finding connected components or shortest paths in graphs.
### [Two Pointers](two-pointers-explained.md)
This technique involves using two pointers to iterate through an array or string simultaneously, often in opposite directions. It's efficient for solving problems involving finding specific sub-sequences, checking palindrome strings, or finding missing elements.

## High-ROI Patterns with Medium Learning
### Hash Tables
These efficient data structures store key-value pairs and allow for quick retrieval based on the key. Understanding hashing functions and collision resolution is key to mastering hash tables, making them valuable for interview preparation.
### Tree DFS (Depth-First Search)
In contrast to BFS, DFS explores a tree by going deeper and deeper along a single branch until it reaches a leaf, then backtracking and exploring other branches. This is useful for tasks like finding all paths in a tree or topological sorting.
### Graph DFS (Depth-First Search)
Similar to Tree DFS, but applied to graphs. DFS can be used for tasks like finding cycles in graphs, topological sorting, or finding connected components.
### Heap
This specialized tree-based data structure maintains a specific order property (e.g., min-heap or max-heap). Mastering heaps is valuable for solving problems involving priority queues, sorting algorithms (e.g., heap sort), and efficient element selection.
### Binary Search
This efficient search algorithm repeatedly divides a sorted array in half until the target element is found. Understanding its time complexity and implementation details is crucial for coding interviews.

## Medium-ROI Patterns with Medium Learning
### Combinatorial DFS (Depth-First Search)
This technique extends the basic DFS algorithm by considering all possible combinations of choices or paths at each step. It's useful for solving problems involving backtracking, permutations, and combinations.
### Trie
This tree-based data structure is optimized for storing and retrieving strings. Understanding trie construction and traversal algorithms is beneficial for solving string-related problems like autocomplete or spell checking.

## Patterns with Low ROI
### Divide and Conquer
This powerful problem-solving paradigm involves dividing a complex problem into smaller subproblems, solving them recursively, and combining the solutions. While conceptually valuable, its practical use in coding interviews might be less frequent compared to other patterns.
### Union Find
This disjoint-set data structure allows for efficiently merging and identifying connected components in a graph. While important in certain scenarios, its specific use cases might not be as common in interview settings.
### Greedy
This heuristic approach makes locally optimal choices at each step with the hope of achieving a globally optimal solution. While intuitive, greedy algorithms can sometimes be incorrect or suboptimal, making them less reliable for interview problems.
### Dynamic Programming
This technique solves overlapping subproblems by storing solutions in a table to avoid recomputing them repeatedly. While a powerful optimization tool, its complexity and specific use cases might not be as frequently tested in interviews compared to other patterns.

> *Remember, this is just a high-level overview based on my current understanding. Each pattern deserves deeper exploration and practice to fully grasp its nuances and applications.*
